//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.2

use std::{str::FromStr, sync::Arc};

use crate::{modules::warmup::action::WarmupAction, onchain::evm::client::EvmClient};
use alloy::{network::Ethereum, providers::Provider, transports::Transport};
use alloy_chains::NamedChain;
use rand::{thread_rng, Rng};
use reqwest::Proxy;
use sea_orm::entity::prelude::*;
use solana_sdk::{pubkey::Pubkey, signature::Keypair};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "account")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub is_active: bool,
    #[sea_orm(unique)]
    pub evm_private_key: String,
    #[sea_orm(unique)]
    pub evm_address: String,
    #[sea_orm(unique)]
    pub eclipse_private_key: String,
    #[sea_orm(unique)]
    pub eclipse_address: String,
    pub proxy: Option<String>,
    pub swap_count: i32,
    pub create_count: i32,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::account_goal::Entity")]
    AccountGoal,
    #[sea_orm(has_many = "super::bridge_module_state::Entity")]
    BridgeModuleState,
}

impl Related<super::account_goal::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::AccountGoal.def()
    }
}

impl Related<super::bridge_module_state::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::BridgeModuleState.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

impl Model {
    pub fn to_evm_client<P, T>(&self, provider: Arc<P>) -> EvmClient<P, T>
    where
        P: Provider<T, Ethereum>,
        T: Transport + Clone,
    {
        EvmClient::new(provider, &self.evm_private_key, NamedChain::Mainnet)
    }

    pub fn eclipse_pubkey(&self) -> Pubkey {
        Pubkey::from_str(&self.eclipse_address).unwrap()
    }

    pub fn eclise_keypair(&self) -> Keypair {
        Keypair::from_base58_string(&self.eclipse_private_key)
    }

    pub fn proxy(&self) -> Option<Proxy> {
        self.proxy.as_ref().map(|p| Proxy::all(p).unwrap())
    }

    pub fn get_random_warmup_action(
        &self,
        goal: super::account_goal::Model,
    ) -> Option<WarmupAction> {
        let mut possible_actions = Vec::new();

        if self.create_count < goal.create_count {
            possible_actions.push(WarmupAction::UnderdogCreate);
        }

        if self.swap_count < goal.swap_count {
            possible_actions.push(WarmupAction::LifinitySwap);
        }

        if possible_actions.is_empty() {
            return None;
        }

        let mut rng = thread_rng();
        let choice = rng.gen_range(0..possible_actions.len());
        Some(possible_actions[choice].clone())
    }
}
